{"meta":{"title":"末明","subtitle":" 测试博客副标题11","description":" 测试博客副描述,位置啦啦啦啦","author":"我的名字","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-11-08T15:30:18.025Z","updated":"2022-11-08T15:30:18.025Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-11-08T15:30:18.017Z","updated":"2022-11-08T15:30:18.017Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"其实人的精神状态就是一个小宇宙，当陨石撞破了脑子里的小地球，整个人的情绪就会变得坑坑洼洼的，月亮的光也会消逝掉。 很多人觉得身体健康就好了啊，但灵魂要是烂透了，就像盘踞黑暗的树根腐朽掉了，外头的叶子盛开得再繁华，本质上都是在奔向绝望。 所以大家要保护好自己的小宇宙。工作，感情，家庭都可以放一放。收拾掉腐烂的根叶，和沾满灰尘的躯体，注入新鲜的氧气，种很多香香的玫瑰花。 同时也允许自己有黑暗的一面，毕竟宇宙因为有了黑暗的留白，日月星辰才显得如此绝色 ————by 德卡先生"},{"title":"标签","date":"2022-05-17T16:31:56.000Z","updated":"2022-11-08T15:30:18.025Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue-Axios","slug":"前端/Vue-axios","date":"2022-11-08T16:00:00.000Z","updated":"2022-11-09T14:46:36.340Z","comments":true,"path":"2022/11/09/前端/Vue-axios/","link":"","permalink":"http://example.com/2022/11/09/%E5%89%8D%E7%AB%AF/Vue-axios/","excerpt":"Vue——axios的简单封装","text":"Vue——axios的简单封装 一. 请求和传递参数在Vue中，发送请求一般是在created 钩子中，放在 mounted 中也没有问题发送请求的前提是安装了 axios ，并且 import axios from ‘axios’ 成功导入Axios官网链接 1. get 请求 get 请求传参，在地址中已 ？xxx&#x3D;xxx 的形式 1234created()&#123; let res = axios.get(&quot;https://www.baidu.com?xxx=xxx&quot;); console.log(res);&#125; 2. post 请求 post 请求传参，在第二个参数中接收 1234567created()&#123; let res = axios.post(&quot;https://www.baidu.com&quot;,&#123; pageNum:1, pageSize:10, &#125;) console.log(res)&#125; 3. 请求配置 请求配置里面可以设置很多属性 123456789101112131415created() &#123; let res = axios(&#123; url: &quot;https://www.baidu.com&quot;,//请求路径 method: &#x27;post&#x27;, // 默认是 get 请求 headers: &#123;&#125;, // 自定义请求头 data: &#123; // post 请求，前端给后端传递的参数 pageNum: 1, pageSize: 5 &#125;, params: &#123;&#125;, // get 请求，前端给后端传递的参数 timeout: 0, // 请求超时 responseType: &#x27;json&#x27; // 返回的数据类型 &#125;) console.log(res);&#125; 二. axios 的简单封装目的：方便统一管理注意：先安装 axios 才可以使用，终端键入：npm i axios，之后回车安装它 1. 配置拦截器在 src 目录下新建 utils 文件夹，该文件夹下创建 request.js 文件 request.js 文件内 首先创建 axios 对象 添加请求拦截器（前端给后端的参数） 添加响应拦截器（后端给前端的数据） 12345678910111213141516171819202122232425262728import axios from &#x27;axios&#x27;// 创建 axios 对象const instance = axios.create(&#123; baseURL: &#x27;http://xxx.xxx.xxx/api&#x27;, // 根路径 timeout: 2000 // 网络延时&#125;)// 添加请求拦截器 =&gt; 前端给后端的参数【还没到后端响应】instance.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);// 添加响应拦截器 =&gt; 后端给前端的数据【后端返回给前端的东西】instance.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response;&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error);&#125;);// 最终返回的对象export default instance 2. 发送请求在需要发请求的组件中，导入 request.js， 之后发送请求即可 demo.vue 组件 在需要使用的组件中 导入 request 直接发送请求即可 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt;demo&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import request from &quot;./utils/request&quot;;export default &#123; name: &quot;App&quot;, data() &#123; return &#123;&#125;; &#125;, created() &#123; // get 请求 request(&#123; url: &quot;/course/category/getSecondCategorys&quot;, &#125;).then((res) =&gt; &#123; console.log(res); &#125;); // post 请求 request(&#123; url: &quot;/course/mostNew&quot;, method: &quot;post&quot;, data: &#123; pageNum: 1, pageSize: 5, &#125;, &#125;).then((res) =&gt; &#123; console.log(res); &#125;); &#125;&#125;&lt;/script&gt; 三. API 的解耦API 解耦的目的: 为了同一个接口可以多次使用 为了方便 api 请求统一管理 1. 配置文件对应的请求在 src 目录下新建 api 文件夹，该文件夹下创建 xxx.js 文件，配置对应请求 eg: .&#x2F;api&#x2F;course.js 文件 搜索与分类接口请求 1234567891011121314151617import request from &quot;../utils/request&quot;;// 获取一级分类（get请求）export function getSendCategorys() &#123; return request(&#123; url: &#x27;/course/category/getSecondCategorys&#x27;, &#125;)&#125;// 查询课程（post请求）export function courseSearch(data) &#123; return request(&#123; url: &#x27;/course/search&#x27;, method: &#x27;post&#x27;, data &#125;)&#125; 2. 获取数据 从文件定义的请求中导入对应函数 获取数据 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; getSendCategorys, courseSearch &#125; from &quot;./api/course&quot;;export default &#123; name: &quot;App&quot;, data() &#123; return &#123;&#125;; &#125;, created() &#123; // 获取一级分类 getSendCategorys().then((res) =&gt; &#123; console.log(res); &#125;); // 查询（有参数的传递） courseSearch(&#123; pageNum: 1, pageSize: 5 &#125;).then((res) =&gt; &#123; console.log(res); &#125;); &#125;&#125;&lt;/script&gt; 文件结构如下：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[]},{"title":"scrcpy","slug":"工具/scrcpy","date":"2022-07-23T16:00:00.000Z","updated":"2022-11-08T15:30:18.017Z","comments":true,"path":"2022/07/24/工具/scrcpy/","link":"","permalink":"http://example.com/2022/07/24/%E5%B7%A5%E5%85%B7/scrcpy/","excerpt":"开源投屏软件 scrcpy 的简单使用GitHub：scrcpy","text":"开源投屏软件 scrcpy 的简单使用GitHub：scrcpy 介绍 轻量： 原生，仅显示设备屏幕 性能： 30~120fps，取决于设备 质量： 分辨率可达 1920×1080 或更高 低延迟： 35~70ms 快速启动： 最快 1 秒内即可显示第一帧 无侵入性： 不会在设备上遗留任何程序 用户利益： 无需帐号，无广告，无需联网 自由： 自由和开源软件 要求: 安卓设备最低需要支持 API 21 (Android 5.0)。 确保设备已开启 adb 调试 连接1.有线连接电脑和手机- 将下载的资源解压到任意目录 - 将手机与电脑用USB连接, USB连接方式选择传输文件 - 打开手机开发者模式，在设置内进入开发人员选项并打开USB调试功能 - 在资源解压目录进入cmd - 输入命令 adb devices,可以看到已连接手机 - 输入命令 scrcpy.exe ，即可成功投屏 2.无线连接- 确保你的电脑和手机在同一局域网中，查看手机ip信息（设置 ==》 关于手机 ==》 状态信息 ==》 IP地址 [若未找到，请根据手机品牌自行百度]） - 测试连接: 在命令行中输入 ping DEVICE_IP (DEVICE_IP 为设备 IP)，若数据包发送成功，则说明在同一局域网下 - 输入命令 adb tcpip 5555 （设置监听端口），回车 - 输入命令 adb connect DEVICE_IP:5555 (将 DEVICE_IP 替换为设备 IP) 连接到您的设备，回车 - 输入命令 scrcpy.exe ，投屏成功 （1）自动配置- 参数 --tcpip 允许自动配置连接。这里有两种方式 - 对于传入的 adb 连接，如果设备（示例ip：192.168.1.1）已经监听了一个端口（通常是5555），运行： - scrcpy --tcpip=192.168.1.1 # 默认端口是5555 - scrcpy --tcpip=192.168.1.1:5555 - 如果adb TCP/IP（无线） 模式在某些设备上不被启用（或者你不知道IP地址），用USB连接设备，然后运行： - scrcpy --tcpip # 无需其他参数 - 这将会自动寻找设备IP地址，启用TCP/IP模式，然后在启动之前连接到设备。 其他1.屏幕设置降低分辨率 1234#通过降低镜像的分辨率来提高性能,要同时限制宽度和高度到某个值 (例如 1024)：scrcpy --max-size 1024scrcpy -m 1024 # 简写#另一边会被按比例缩小以保持设备的显示比例 修改码率 123#默认码率是 8 Mbps。改变视频码率 (例如改为 2 Mbps)：scrcpy --bit-rate 2Mscrcpy -b 2M # 简写 限制帧率 12#要限制采集的帧率:scrcpy --max-fps 15 画面裁剪 1234#可以对设备屏幕进行裁剪，只镜像屏幕的一部分#如果同时指定了 --max-size，会先进行裁剪，再进行缩放scrcpy --crop 1224:1440:0:0 # 以 (0,0) 为原点的 1224x1440 像素 锁定屏幕方向 12345scrcpy --lock-video-orientation # 初始（目前）方向scrcpy --lock-video-orientation=0 # 自然方向scrcpy --lock-video-orientation=1 # 逆时针旋转 90°scrcpy --lock-video-orientation=2 # 180°scrcpy --lock-video-orientation=3 # 顺时针旋转 90° 2.多设备12345678#如果 adb devices 列出了多个设备，您必须指定设备的 序列号scrcpy --serial 0123456789abcdefscrcpy -s 0123456789abcdef # 简写#如果设备通过 TCP/IP 连接：scrcpy --serial 192.168.0.1:5555scrcpy -s 192.168.0.1:5555 # 简写 3.窗口设置标题 12#窗口的标题默认为设备型号。可以通过如下命令修改：scrcpy --window-title &quot;我的设备&quot; 位置和大小 12#指定初始的窗口位置和大小：scrcpy --window-x 100 --window-y 100 --window-width 800 --window-height 600 窗口置顶 1scrcpy --always-on-top 屏幕旋转 12# 0: 无旋转 1: 逆时针旋转 90° 2: 旋转 180° 3: 顺时针旋转 90°scrcpy --rotation 1 关闭设备屏幕 12scrcpy --turn-screen-offscrcpy -S 快捷键在以下列表中, MOD 是快捷键的修饰键。 默认是 (左) Alt 或 (左) Super(Super 键通常是指 Windows 或 Cmd 键)您可以使用 –shortcut-mod 来修改。可选的按键有 lctrl、rctrl、lalt、ralt、lsuper 和 rsuper 12345# 使用右 Ctrl 键scrcpy --shortcut-mod=rctrl# 使用左 Ctrl 键 + 左 Alt 键，或 Super 键scrcpy --shortcut-mod=lctrl+lalt,lsuper 操作 快捷键 全屏 MOD + f 向左旋转屏幕 MOD + ← (左箭头) 向右旋转屏幕 MOD + → (右箭头) 将窗口大小重置为1:1 (匹配像素) MOD + g 将窗口大小重置为消除黑边 MOD + w &#x2F; 双击左键¹ 点按 主屏幕 MOD + h &#x2F; 中键 点按 返回 MOD + b &#x2F; 右键² 点按 切换应用 MOD + s &#x2F; 第4键³ 点按 菜单 (解锁屏幕)⁴ MOD + m 点按 音量 + MOD + ↑ (上箭头) 点按 音量- MOD + ↓ (下箭头) 点按 电源 MOD + p 打开屏幕 鼠标右键² 关闭设备屏幕 (但继续在电脑上显示) MOD + o 旋转设备屏幕 MOD + r 展开通知面板 MOD + n &#x2F; 第5键³ 展开设置面板 MOD + n + n &#x2F; 双击第5键³ 收起通知面板 MOD + Shift + n 复制到剪贴板⁵ MOD + c 剪切到剪贴板⁵ MOD + x 同步剪贴板并粘贴⁵ MOD + v 注入电脑剪贴板文本 MOD + Shift + v 打开&#x2F;关闭FPS显示 (至标准输出) MOD + i 捏拉缩放 Ctrl + 按住并移动鼠标 拖放 APK 文件 从电脑安装 APK 文件 拖放非 APK 文件 将文件推送至设备 ¹双击黑边可以去除黑边。²点击鼠标右键将在屏幕熄灭时点亮屏幕，其余情况则视为按下返回键 。³鼠标的第4键和第5键。⁴对于开发中的 react-native 应用程序，MENU 触发开发菜单。⁵需要安卓版本 Android &gt;&#x3D; 7。 有重复按键的快捷键通过松开再按下一个按键来进行","categories":[{"name":"instrument","slug":"instrument","permalink":"http://example.com/categories/instrument/"}],"tags":[]},{"title":"Git","slug":"前端/Git","date":"2022-06-06T16:00:00.000Z","updated":"2022-11-08T15:30:18.014Z","comments":true,"path":"2022/06/07/前端/Git/","link":"","permalink":"http://example.com/2022/06/07/%E5%89%8D%E7%AB%AF/Git/","excerpt":"","text":"Git 常用命令1. 创建全新仓库1234# 在当前目录创建一个新的 Git 代码仓库git init# 新建一个目录，将其初始化为代码库git init [project] 2. 克隆远程仓库12#克隆远程仓库项目和他的整个代码历史记录（版本信息）git clone [url] 3. 查看文件状态12345#查看指定文件状态git status [filename]查看所有文件状态git status 4. 暂存 提交123456789101112131415161718192021222324252627#添加指定文件到暂存区git add [file1] [file2] ...#添加指定文件夹到暂存区，包括子目录git add [dir]#添加当前目录的所有文件到暂存区git add .#提交暂存区到本地仓库git commit -m &quot;commit_message&quot;#提交暂存区的指定文件到本地仓库区git commit [file1] [file2] ... -m [message]#提交工作区自上次commit之后的变化，直接到仓库区，跳过了add,对新文件无效git commit -a#提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 5. 查看 创建 删除分支12345678910111213141516171819202122#查看本地分支git branch#查看远程版本库的分支列表git branch -r#查看所有分支列表，包括本地和远程git branch -a#查看本地分支对应的远程分支git branch -vv#根据当前分支创建指定分支，创建完成依然停留在当前分支上git branch [name]#删除本地分支git branch -d [name]#强制删除本地分支git branch -D [name]#删除远程分支git push origin --delete [name] 6. 切换分支1234567891011121314#放弃单个文件的修改git checkout [fileName]#放弃当前目录的修改git checkout .# 签出到指定分支git checkout [name]# 根据当前分支创建并签出到此分支git checkout -b [name]#切换到指定分支git switch [name] 7. 拉取 推送远程分支1234567891011121314151617#将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支)git pull#将远程指定分支 拉取到 本地当前分支上git pull origin [name]#将本地当前分支 推送到 与本地当前分支同名的远程分支上 (需要先关联远程分支)git push#将本地指定分支 推送到 与本地当前分支同名的远程分支上git push origin [branch_name]#本地代码强制推送覆盖到远程git push -f origin &lt;远程分支名&gt;#将本地分支与远程同名分支相关联git push -u origin [本地分支名] 8. 标签 tag123456789101112131415161718192021222324252627282930313233#查看当前仓库所有标签git tag#查看所有标签及说明git tag -n#搜索符合条件的标签git tag -l &quot;1.0.*&quot;# 查看指定标签具体信息git show [标签名]#创建标签git tag &quot;[标签名]&quot;#创建带有说明的标签git tag -a [标签名] -m &quot;[说明文字]&quot;#给指定的commit打标签git tag -a &quot;[标签名]&quot; [commitID]#推送指定标签到远程git push origin [标签名]#推送全部本地标签到远程git push origin --tags#删除本地标签git tag -d &quot;[标签名]&quot;#删除远程标签git push origin --delete tag [标签名] 9. 版本回退123456789101112131415161718#查看已提交日志git log#查看所有提交log，显示对应版本号git reflog#回退到上一次提交 git reset --hard HEAD^#回退到某一分支，不保留后续更改git reset --hard &lt;分支id&gt;#回退到某一分支，保留后续更改为待暂存状态git reset --mixed &lt;分支id&gt;#回退到某一分支，保留后续更改为待提交状态git reset --soft &lt;分支id&gt; 10. 工作区暂存123456789101112131415161718192021#查看stash了哪些存储git stash list#执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。git stash save &quot;暂存说明&quot;#应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;git stash apply #如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; git stash apply stash@&#123;$num&#125;#命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;git stash pop #如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;git stash pop stash@&#123;$num&#125;#丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储git stash drop stash@&#123;$num&#125;#删除所有缓存的stashgit stash clear 文件的四种状态- Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. - Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 - Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 - Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[]},{"title":"Promise的状态和现象","slug":"前端/Promise","date":"2022-06-05T16:00:00.000Z","updated":"2022-11-08T15:30:18.014Z","comments":true,"path":"2022/06/06/前端/Promise/","link":"","permalink":"http://example.com/2022/06/06/%E5%89%8D%E7%AB%AF/Promise/","excerpt":"","text":"Promise 的三种状态：pending fulfilled rejected123456789101112const promise1 = new Promise((resolve, reject) =&gt;&#123; &#125;)console.log(&quot;promise1&quot;,promise1); // 此时 promise1 的状态为 pendingconst promise2 = new Promise((resolve, reject) =&gt;&#123; setTimeout(()=&gt;&#123; console.log(&#x27;promise2 resolve 前&#x27;,promise2) // 此时 promise2 的状态为 pending resolve(); console.log(&#x27;promise2 resolve 后&#x27;,promise2) // 此时 promise2 的状态为 fulfilled &#125;)&#125;) 1234567const promise3 = new Promise((resolve, reject) =&gt;&#123; setTimeout(()=&gt;&#123; console.log(&#x27;promise3 resolve 前&#x27;,promise2) // 此时 promise3 的状态为 pending resolve(); console.log(&#x27;promise3 resolve 后&#x27;,promise2) // 此时 promise3 的状态为 rejected &#125;)&#125;) 更为简便的方法， 定义时直接改变 Promise 的状态 123456789101112131415161718192021222324const promise4 = Promise.resolve(&#x27;promise4 data&#x27;)console.log(&#x27;promise4&#x27;, promise4) //此时 promise4 状态为 fulfilledpromise4.then(data=&gt;&#123; console.log(&#x27;data&#x27;,data)&#125;).catch(err=&gt;&#123; console.log(&#x27;error&#x27;,err)&#125;)/** 如果 Promise 执行之后是 fulfilled 的状态，那么就会执行 then 当中的回调函数，同时 data 就是传的字符串，* 不会执行到 catch 中* */const promise5 = Promise.reject(&#x27;promise5 error&#x27;)console.log(&#x27;promise5&#x27;, promise5) //此时 promise4 状态为 rejectedpromise5.then(data=&gt;&#123; console.log(&#x27;data2&#x27;,data2)&#125;).catch(err=&gt;&#123; console.log(&#x27;error2&#x27;,err2)&#125;)/** 同理，如果 Promise 执行之后是 rejected 的状态，那么就会执行 catch 当中的回调函数，* 同时 err2 就是传的字符串，不会执行到 then 中* */ Promise 解决回调地狱回调地狱示例 1234567891011let fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./a.txt&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123; fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123; console.log(data) &#125;) &#125;)&#125;)//代码耦合性太强，牵一发而动全身，难以维护//大量冗余代码相互嵌套，可读性极差 解决 123456789101112131415161718192021let fs = require(&#x27;fs&#x27;)function read(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(url,&#x27;utf8&#x27;,function(error,data)&#123; error &amp;&amp; reject(error) resolve(data) &#125;) &#125;)&#125;//promise 采用的是链式调用，而不是嵌套调用read(&#x27;./a.txt&#x27;) //read 方法返回值为 Promise 的实例对象 .then(data=&gt;&#123; // .then 为第一个 Promise 实例成功之后的回调 return read(data) // 在第一个 .then 中返回一个新的Promise 实例对象 &#125;) .then(data=&gt;&#123; // 调用 .then， 此为上一个 .then 的返回值（新的 Promise 实例）指定成功之后的回调 return read(data) // 再第二个 .then 中再返回一个新的 Promise 实例对象 &#125;) .then(data=&gt;&#123; // 调用 .then， 此为上一个 .then 的返回值（新的 Promise 实例）指定成功之后的回调 console.log(data) // 以此类推 链式调用，单层嵌套， &#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-21T16:00:00.000Z","updated":"2022-11-08T15:30:18.013Z","comments":true,"path":"2022/05/22/hello-world/","link":"","permalink":"http://example.com/2022/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"学习使我快乐","slug":"后端/222","date":"2022-05-20T02:03:14.000Z","updated":"2022-11-08T15:30:18.016Z","comments":true,"path":"2022/05/20/后端/222/","link":"","permalink":"http://example.com/2022/05/20/%E5%90%8E%E7%AB%AF/222/","excerpt":"学习是一件值得努力的事情","text":"学习是一件值得努力的事情 如何让自己静下心来安静的学习 首先需要信念 其次需要目标","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"instrument","slug":"instrument","permalink":"http://example.com/categories/instrument/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]}